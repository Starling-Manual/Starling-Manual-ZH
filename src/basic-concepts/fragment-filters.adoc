== 片段过滤器

到目前为止，我们所有的渲染都是映射到包含（或不包含）贴图的网格。
你可以移动网格，缩放它们，旋转它们，也许以不同的颜色着色。
总而言之，可能性是相当有限的 - 游戏的外观完全决定于纹理。

在某些时候，你会遇到这种方法的极限; 也许你需要一个图像的变体，多种颜色，模糊或阴影。
如果将所有这些变体添加到纹理图集中，您将很快耗尽内存。

Fragment filters(片段过滤器)可以帮助你解决上述问题。
过滤器可以附加到任何显示对象（包括容器），并且可以完全改变其外观。

例如，假设您要向对象添加高斯模糊：

[source, as3]
----
var filter:BlurFilter = new BlurFilter(); // <1>
object.filter = filter; // <2>
----
<1> 创建并配置所需滤镜的实例。
<2> 将滤镜分配给显示对象的`filter`属性。

使用分配的滤镜，显示对象的呈现将被修改为这样：

* 每帧，目标对象都呈现为一个纹理。
* 纹理由片段着色器（直接在GPU上）处理。
* 一些滤镜使用多遍，即一个着色器的输出作为下一次的输入。
* 最后一个着色器的输出被绘制到后台缓冲区。

.片段过滤器的渲染管道。
image::filter-pipeline.png[Filter Pipeline, 700]

这种方法非常灵活，允许产生各种不同的效果（我们将很快看到）。
此外，它极大地利用了GPU的并行处理能力;所有昂贵的逐像素处理逻辑都在图形芯片上执行。

也就是说：滤镜会中断批处理，每个滤镜工作时需要单独的绘制调用。
无论是内存使用和还是渲染性能，他们消耗都不低。
所以要小心，明智地使用它们。

=== 展示

Starling有一些非常有用且易用的滤镜。

==== 模糊滤镜

对显示对象应用高斯模糊。可以分别对x轴和y轴设置模糊的强度。

* 每个模糊方向，滤镜需要至少一个渲染过程（绘制调用）。
* 每个强度单位，滤镜需要一次pass（1的强度需要一次pass，2的强度通过2次pass）。
* 通过降低滤波器分辨率，而不是提高模糊强度, 来达到相似的模糊效果，这样会节省更多的性能。

.激活的模糊滤镜。
image::filter-blur.png[BlurFilter, 600]

==== 颜色矩阵滤镜

动态地更改对象的颜色。更改对象的亮度，饱和度，色调或将其完全反转。

该滤镜将每个像素的颜色和α值乘以4×5矩阵。
这是一个非常灵活的设计，但是设置相应的矩阵也很麻烦。
为此，该类包含几个方法，帮助您设置想要实现效果的矩阵（例如，更改色调或饱和度）。

* 您可以在一个滤镜实例中组合多个颜色转换。
  例如，要更改亮度和饱和度，请调用滤镜内置的相应方法。
* 此滤镜总是需要一次pass。

.激活的颜色矩阵滤镜。
image::filter-colormatrix.png[ColorMatrixFilter, 600]

==== DropShadow- and GlowFilter

这两个滤镜在前面绘制原始对象，并在其后添加一个模糊和着色的变体。

* 这也使它们相当昂贵，因为他们还需要给模糊滤镜添加一次额外的pass。

.激活的阴影和发光滤镜.
image::filter-dropshadow+glow.png[DropShadow and Glow filter, 300]

==== 置换滤镜

根据贴图中的颜色来替换目标对象的像素。

* 不是很容易使用，但非常强大！
* 水面反射，放大镜，爆炸的冲击波 - 这个滤镜都可以做到。
ifdef::target-handbook[]
* 我们将在后面的章节中讨论这个滤镜的细节。
endif::[]

.包含几个不同贴图的置换滤镜。
image::filter-displacementmap.png[Other filters, 450]

==== 滤镜链

要在一个显示对象上组合多个滤镜，可以通过FilterChain类将它们链接在一起。
滤镜将按给定顺序处理;每个滤镜的绘制调用的数量简单地相加。

.颜色矩阵和阴影滤镜链接在一起。
image::filter-chain.png[FilterChain, 150]

=== 性能提示

我上面提到它：虽然GPU处理部分是非常高效的，但额外的绘制调用使片段过滤器相当昂贵。
但是，Starling尽力优化滤镜性能。

* 当一个对象接连两帧不改变它相对于舞台的位置（或其他属性，比如尺度和颜色），Starling识别到这一点，会自动缓存过滤器输出。
  这意味着滤镜将不再需要被处理;相反，它的行为就像一个单一的图像。
* 另一方面，当对象不断移动时，最后的滤镜总是通过后台缓冲区直接呈现而不是纹理。
  这只有一次绘制调用。
* 如果你想继续使用滤镜输出，即使对象在移动，调用`filter.cache（）`。
  同样，这将使对象的行为就像一个静态图像。
  但是，如果目标对象图像有任何更改，您必须再次调用`cache`（或`uncache`）。
* 为了节省内存，不妨试试'resolution'和'textureFormat'属性。
  但这将降低图像质量。

=== 更多滤镜

您想知道如何创建自己的滤镜吗？
不要担心，我们将探讨该主题<<自定义滤镜,稍后...>>。

在此期间，您可以尝试使用由其他Starling开发人员创建的滤镜。
一个很好的例子是 https://github.com/devon-o/Starling-Filters[filter collection] by devon-o.
