== 动画

动画不仅是任何游戏的基本组成部分;也为现代商业应用程序提供平滑且生动的过渡。
显然，提供一套能快速响应设置且直观的接口对控制动画大有裨益。
正因为如此，Starling内置了一个非常灵活的动画引擎。

如你所想，动画可以简单分为两种类型。

* 第一种,动画变化非常动态，你无法预知会发生什么。比如有一个向玩家移动的敌人：它的方向和速度需要根据环境每一帧更新。每个额外的力量或碰撞都可能改变移动轨迹。

* 另一种,预定义动画，这种动画遵循一定的规律;你从开始就知道会发生什么。比如消息框中淡出,或者从一个屏幕过渡到另一个屏幕。

我们将在以下部分示例这两种类型。

=== 帧事件

在一些游戏引擎中，有一个叫做run-loop的机制。
这是一个无限循环，不断更新场景的所有元素。

在Starling中，由于显示列表架构，这样的循环没有什么意义。
我们已经将游戏分成许多不同的自定义显示对象，每个人都应该知道哪段时间该做什么。

这正是帧事件(EnterFrameEvent)的要点：允许显示对象随时间更新自身。
每帧，该事件被分派给位于显示列表中的所有显示对象。
下面讲如何使用它：

[source, as3]
----
public function CustomObject()
{
    addEventListener(Event.ENTER_FRAME, onEnterFrame); // <1>
}

private function onEnterFrame(event:Event, passedTime:Number):void // <2>
{
    trace("Time passed since last frame: " + passedTime);
    bird.advanceTime(passedTime);
}
----
<1> 您可以在任何地方向此事件添加侦听器，但构造函数是一个很好的选择。
<2> 这是对应的事件侦听器的样子。

方法`onEnterFrame`每帧被调用一次，并且它沿着自上一帧以来已经过去的时间传递。
有了这些信息，你可以移动你的敌人，更新太阳的高度，或做任何其他需要。

这个事件背后的蕴含力量是，每次事件发生时你可以做完全不同的事情。
你可以动态地响应游戏的当前状态。

例如，你可以让敌人向玩家迈进一步;甚至一个简单形式的敌人AI，如果你愿意！

=== Tweens

现在到预定义的动画。
它们非常常见，例如movement，scale，fade等。
Starling处理这些动画的方法很简单 - 但同时非常灵活。
基本上，你可以缓动任何对象的任何属性，只要它是数字（`Number`，`int`，`uint`）。
这些动画描述被封装在称为Tween的对象中。

NOTE: 术语“Tween”来自手工绘制的动画，其中铅笔插画将绘制重要的关键帧，而团队的其余人员绘制关键帧之间(in-between)的其它帧。

.渐变帧。
image::soccer-tween.png[Soccer Tween]

了解了这些理论，接下来我们举个例子：

[source, as3]
----
var tween:Tween = new Tween(ball, 0.5);

tween.animate("x", 20);
tween.animate("scale", 2.0);
tween.animate("alpha", 0.0);
----

这个补间描述了一个动画，将“ball”对象移动到“x = 20”，将其放大两倍，并降低其不透明度，直到它不可见。
所有这些变化将在半秒内同时进行。
起始值仅仅是指定属性的当前值。

这个示例告诉我们：

* 你可以对一个对象的任意属性进行动画处理
* 您可以在一个补间对象中组合多个动画。

Apropos: 由于缩放，淡入淡出和移动的频率很高，所以Tween类也提供了更为具体的方法。
你可以这样写:

[source, as3]
----
tween.moveTo(20, 0); // animate "x" and "y"
tween.scaleTo(2);    // animate "scale"
tween.fadeTo(0);     // animate "alpha"
----

补间动画的一个有趣的功能是，你可以改变动画的执行方式，例如。 让它先慢后快。
这是通过指定过渡类型做到的。

.可用的过渡类型。 缺省值为“linear”。
image::transitions.png[Transitions]

以下示例显示如何指定这样的转换，并介绍此类的更多功能。

[source, as3]
----
var tween:Tween = new Tween(ball, 0.5, Transitions.EASE_IN); // <1>
tween.onStart    = function():void { /* ... */ };
tween.onUpdate   = function():void { /* ... */ }; // <2>
tween.onComplete = function():void { /* ... */ };
tween.delay = 2; // <3>
tween.repeatCount = 3; // <4>
tween.reverse = true;
tween.nextTween = explode; // <5>
----
<1> 通过第三个构造函数参数指定过渡类型。
<2> 这些回调在补间启动时，每帧更新时或完成时执行。
<3> 延迟两秒钟再执行动画。
<4> 重复播放动画三次，可选择以yoyo风格（`reverse`）。 如果将`repeatCount`设置为零，动画将被无限重复。
<5> 指定下一个动画补间，在此动画完成后立即开始。

我们刚刚创建和配置了一个补间动画 - 但什么也没有发生。
一个tween对象描述了动画如何运行，但它并未开始运行。

你可以通过tweens`advanceTime`方法手动执行：

[source, as3]
----
ball.x = 0;
tween = new Tween(ball, 1.0);
tween.animate("x", 100);

tween.advanceTime(0.25); // -> ball.x =  25
tween.advanceTime(0.25); // -> ball.x =  50
tween.advanceTime(0.25); // -> ball.x =  75
tween.advanceTime(0.25); // -> ball.x = 100
----

Hm, that works, but it's a little cumbersome, isn't it?
Granted, one could call `advanceTime` in an `ENTER_FRAME` event handler, but still: as soon as you've got more than one animation, it's bound to become tedious.

Don't worry: I know just the guy for you.
He's really good at handling such things.

=== Juggler

The juggler accepts and executes any number of animatable objects.
Like any true artist, it will tenaciously pursue its true passion, which is: continuously calling `advanceTime` on everything you throw at it.

There is always a default juggler available on the active Starling instance.
The easiest way to execute an animation is through the line below -- just add the animation (tween) to the default juggler and you are done.

[source, as3]
----
Starling.juggler.add(tween);
----

When the tween has finished, it will be thrown away automatically.
In many cases, that simple approach will be all you need!

In other cases, though, you need a little more control.
Let's say your stage contains a game area where the main action takes place.
When the user clicks on the pause button, you want to pause the game and show an animated message box, maybe providing an option to return to the menu.

When that happens, the game should freeze completely: none of its animations should be advanced any longer.
The problem: the message box itself use some animations, too, so we can't just stop the default juggler.

In such a case, it makes sense to give the game area its own juggler.
As soon as the exit button is pressed, this juggler should just stop animating anything.
The game will freeze in its current state, while the message box (which uses the default juggler, or maybe another one) animates just fine.

When you create a custom juggler, all you have to do is call its `advanceTime` method in every frame.
I recommend using jugglers the following way:

[source, as3]
----
public class Game // <1>
{
    private var _gameArea:GameArea;

    private function onEnterFrame(event:Event, passedTime:Number):void
    {
        if (activeMsgBox)
            trace("waiting for user input");
        else
            _gameArea.advanceTime(passedTime); // <2>
    }
}

public class GameArea
{
    private var _juggler:Juggler; // <3>

    public function advanceTime(passedTime:Number):void
    {
        _juggler.advanceTime(passedTime); // <4>
    }
}
----
<1> In your Game's root class, listen to `Event.ENTER_FRAME`.
<2> Advance the `gameArea` only when there is no active message box.
<3> The _GameArea_ contains its own juggler. It will manage all in-game animations.
<4> The juggler is advanced in its `advanceTime` method (called by _Game_).

That way, you have neatly separated the animations of the game and the message box.

By the way: the juggler is not restricted to Tweens.
As soon as a class implements the `IAnimatable` interface, you can add it to the juggler.
That interface has only one method:

[source, as3]
----
function advanceTime(time:Number):void;
----

By implementing this method, you could e.g. create a simple MovieClip-class yourself.
In its `advanceTime` method, it would constantly change the texture that is displayed.
To start the movie clip, you'd simply add it to a juggler.

This leaves one question, though: when and how is an object removed from the juggler?

==== Stopping Animations

When a tween finishes, it is removed from the juggler automatically.
If you want to abort the animation before it is finished, you simply remove it from the juggler.

Let's say you just created a tween that animates a ball and added it to the default juggler:

[source, as3]
----
tween:Tween = new Tween(ball, 1.5);
tween.moveTo(x, y);
Starling.juggler.add(tween);
----

There are several ways you can abort that animation.
Depending on the circumstances, simply pick the one that suits your game logic best.

[source, as3]
----
var animID:uint = juggler.add(tween);

Starling.juggler.remove(tween); // <1>
Starling.juggler.removeTweens(ball); // <2>
Starling.juggler.removeByID(animID); // <3>
Starling.juggler.purge(); // <4>
----
<1> Remove the tween directly. This works with any `IAnimatable` object.
<2> Remove all tweens that affect the ball. Only works for tweens!
<3> Remove the tween by its ID. Useful when you don't have access to the _Tween_ instance.
<4> If you want to abort everything, purge the juggler.

Be a little careful with the `purge` method, though: if you call it on the default juggler, another part of your code might suddenly be faced with an aborted animation, bringing the game to a halt.
I recommend you use `purge` only on your custom jugglers.

==== Automatic Removal

You might have asked yourself how the _Tween_ class manages to have tweens removed from the juggler automatically once they are completed.
That's done with the `REMOVE_FROM_JUGGLER` event.

Any object that implements `IAnimatable` can dispatch such an event; the juggler listens to those events and will remove the object accordingly.

[source, as3]
----
public class MyAnimation extends EventDispatcher implements IAnimatable
{
    public function stop():void
    {
        dispatchEventWith(Event.REMOVE_FROM_JUGGLER);
    }
}
----

==== Single-Command Tweens

While the separation between tween and juggler is very powerful, it sometimes just stands in the way, forcing you to write a lot of code for simple tasks.
That's why there is a convenience method on the juggler that allows you to create and execute a tween with a single command.
Here's a sample:

[source, as3]
----
juggler.tween(msgBox, 0.5, {
   transition: Transitions.EASE_IN,
   onComplete: function():void { button.enabled = true; },
   x: 300,
   rotation: deg2rad(90)
});
----

This will create a tween for the `msgBox` object with a duration of 0.5 seconds, animating both the `x` and `rotation` properties.
As you can see, the `{}`-parameter is used to list all the properties you want to animate, as well as the properties of the Tween itself.
A huge time-saver!

=== Delayed Calls

Technically, we have now covered all the animation types Starling supports.
However, there's actually another concept that's deeply connected to this topic.

Remember _Einstein_, our dog-hero who introduced us to the event system?
The last time we saw him, he had just lost all his health points and was about to call `gameOver`.
But wait: don't call that method immediately -- that would end the game too abruptly.
Instead, call it with a delay of, say, two seconds (time enough for the player to realize the drama that is unfolding).

To implement that delay, you could use a native _Timer_ or the `setTimeout`-method.
However, you can also use the juggler, and that has a huge advantage: you remain in full control.

It becomes obvious when you imagine that the player hits the "Pause" button right now, before those two seconds have passed.
In that case, you not only want to stop the game area from animating; you want this delayed `gameOver` call to be delayed even more.

To do that, make a call like the following:

[source, as3]
----
juggler.delayCall(gameOver, 2);
----

The `gameOver` function will be called two seconds from now (or longer if the juggler is disrupted).
It's also possible to pass some arguments to that method.
Want to dispatch an event instead?

[source, as3]
----
juggler.delayCall(dispatchEventWith, 2, "gameOver");
----

Another handy way to use delayed calls is to perform periodic actions.
Imagine you want to spawn a new enemy once every three seconds.

[source, as3]
----
juggler.repeatCall(spawnEnemy, 3);
----

[NOTE]
====
Behind the scenes, both `delayCall` and `repeatCall` create an object of type _DelayedCall_.
Just like the `juggler.tween` method is a shortcut for using tweens, those methods are shortcuts for creating delayed calls.
====

To abort a delayed call, use one of the following methods:

[source, as3]
----
var animID:uint = juggler.delayCall(gameOver, 2);

juggler.removeByID(animID);
juggler.removeDelayedCalls(gameOver);
----

=== Movie Clips

You might have noticed the _MovieClip_ class already when we looked at the class diagram surrounding _Mesh_.
That's right: a _MovieClip_ is actually just a subclass of _Image_ that changes its texture over time.
Think of it as Starling's equivalent of an animated GIF!

==== Acquiring Textures

It is recommended that all frames of your movie clip are from one texture atlas, and that all of them have the same size (if they have not, they will be stretched to the size of the first frame).
You can use tools like _Adobe Animate_ to create such an animation; it can export directly to Starling's texture atlas format.

This is a sample of a texture atlas that contains the frames of a movie clip.
First, look at the XML with the frame coordinates.
Note that each frame starts with the prefix `flight_`.

[source, xml]
----
<TextureAtlas imagePath="atlas.png">
    <SubTexture name="flight_00" x="0"   y="0" width="50" height="50" />
    <SubTexture name="flight_01" x="50"  y="0" width="50" height="50" />
    <SubTexture name="flight_02" x="100" y="0" width="50" height="50" />
    <SubTexture name="flight_03" x="150" y="0" width="50" height="50" />
    <!-- ... -->
</TextureAtlas>
----

Here is the corresponding texture:

.The frames of our MovieClip.
image::flight-animation.png[Flight Animation]

==== Creating the MovieClip

Now let's create the MovieClip.
Supposing that the `atlas` variable points to a _TextureAtlas_ containing all our frames, that's really easy.

[source, as3]
----
var frames:Vector.<Texture> = atlas.getTextures("flight_"); // <1>
var movie:MovieClip = new MovieClip(frames, 10); // <2>
addChild(movie);

movie.play();
movie.pause(); // <3>
movie.stop();

Starling.juggler.add(movie); // <4>
----
<1> The `getTextures` method returns all textures starting with a given prefix, sorted alphabetically.
<2> That's ideal for our _MovieClip_, because we can pass those textures right to its constructor. The second parameter depicts how many frames will be played back per second.
<3> Those are the methods controlling playback of the clip. It will be in "play" mode per default.
<4> Important: just like any other animation in Starling, the movie clip needs to be added to the juggler!

Did you notice how we referenced the textures from the atlas by their prefix `flight_`?
That allows you to create a mixed atlas that contains other movie clips and textures, as well.
To group the frames of one clip together, you simply use the same prefix for all of them.

The class also supports executing a sound or an arbitrary callback whenever a certain frame is reached.
Be sure to check out its API reference to see what's possible!

==== More Complex Movies

A downside of this animation technique has to be mentioned, though: you will run out of texture memory if your animations are either very long or if the individual frames are very big.
If your animations take up several big texture atlases, they might not fit into memory.

For these kinds of animations, you need to switch to a more elaborate solution: skeletal animation.
This means that a character is split up into different parts (bones); those parts are then animated separately (according to the character's skeleton).
This is extremely flexible.

Support for such animations isn't part of Starling itself, but there are several other tools and libraries coming to the rescue.
All of the following work really well with Starling:

* http://esotericsoftware.com/[Spine]
* https://github.com/threerings/flump[Flump]
* http://dragonbones.github.io/[Dragon Bones]
* http://gafmedia.com[Generic Animation Format]
