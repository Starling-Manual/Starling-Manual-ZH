== 显示编程
ifndef::imagesdir[:imagesdir: ../../img]

完成了所有的设置过程，我们可以开始实际把一些内容到显示到屏幕上！

在您创建的每个应用程序中，您的主要任务之一是将其拆分为多个逻辑单元。
通常，这些单元将具有可视化表示形式。
换句话说：每个单元将是一个显示对象。

=== 显示对象

屏幕上显示的所有元素其类型都是显示对象。
`starling.display`包包括抽象_DisplayObject_类;它提供了许多不同类型的基本显示对象，例如图像，影片剪辑和文本等等。

_DisplayObject_类提供了所有显示对象共有的方法和属性。
例如，以下属性用于配置对象在屏幕上的位置：

* `x`，`y`：当前坐标系中的位置。
* `width`，`height`：对象的大小（以点为单位）。
* `scaleX`，`scaleY`：另一种方式来查看对象大小; “1.0”表示未缩放，“2.0”将尺寸加倍等。
* `rotation`：对象绕其原点旋转（以弧度表示）。
* `skewX`，`skewY`：水平和垂直倾斜（以弧度表示）。

其他属性修改像素在屏幕上的显示方式：

* `blendMode`：确定对象的像素与下面的像素混合。
* `filter`：修改对象外观的特殊GPU程序（着色器）。过滤器可以模糊对象或添加投影。
* `mask`：mask删除某个区域外的所有部分。
* `alpha`：对象的不透明度，从“0”（不可见）到“1”（完全不透明）。
* `visible`：如果为false，则对象将完全隐藏。

以上这些是每个显示对象必须支持的基本属性。
下面让我们看看Starling关于这方面的API架构：

[plantuml, class-hierarchy]
....
include::../defaults.plantuml[]

abstract class DisplayObject
abstract class DisplayObjectContainer

DisplayObject <|-- Mesh
DisplayObject <|-- DisplayObjectContainer
DisplayObjectContainer <|-- Stage
DisplayObjectContainer <|-- Sprite
DisplayObjectContainer <|-- Button
DisplayObjectContainer <|-- TextField
Mesh <|-- Quad
Quad <|-- Image
Image <|-- MovieClip
....

你会注意到，图表分成两个主要的子分支。
第一个分支，有一些类扩展自`Mesh`：例如`Quad`，`Image`和`MovieClip`。

网格是Starling的渲染架构的基本组成部分。
实际上一切被绘制到屏幕上的对象都是网格！
_Stage3D_不能绘制任何东西，除了三角形，一个网格其实是一系列的点，这些点按一定的顺序组成三角形。

第二个分支，你会发现一些扩展自_DisplayObjectContainer_的类。
顾名思义，这个类充当其他显示对象的容器。
它可以将显示对象组织成逻辑系统 - _display list_（显示列表）。

=== 显示列表

被渲染的所有显示对象的层次结构称为_display list_。
_Stage_是显示列表的根容器。
把"stage"(舞台)按字面上的意思理解：你的用户（观众）只会看到已经进入舞台的对象（演员）。
当您开始创建Starling时，舞台将自动被创建。
连接到舞台（直接或间接）的所有内容都将被渲染。

当我说“连接到”时，我的意思是需要一个_parent-child_关系。
为了使一个对象出现在屏幕上，你应该把它添加(addChild)到舞台，或任何其他连接到舞台的_DisplayObjectContainer_上。

.Display objects are organized in the display list.
image::display-list.png[Display List, 350]

舞台的第一个（通常是唯一的）子对象是_application root_：这是你传递给Starling构造函数的类。
就像舞台，它可能也是一个_DisplayObjectContainer_。
你将通过它来接管显示列表！

您将创建容器，其中容器将包含其他容器和网格（例如图片）。
在树型的显示列表中，这些网格构成叶子：它们不能再包含任何子对象。

这一切听起来似乎很抽象，让我们看一个具体的例子：一个聊天气泡。
要创建聊天气泡，您需要一个图像（对于气泡）和一些文本（对于讲话内容）。

这两个对象应该作为一个整体：当移动时，图像和文本应该跟随。
同样的，应该一起适应大小，缩放，旋转等的变化。
我们可以把这些对象放在一个非常轻量级的_DisplayObjectContainer_：_Sprite_中来实现。

[NOTE]
.DisplayObjectContainer vs. Sprite
====
_DisplayObjectContainer_和_Sprite_可以几乎具有相同的意义。
这两个类之间的唯一区别是，一个（_DisplayObjectContainer_）是抽象的，而另一个（_Sprite_）不是。
因此，您可以使用_Sprite_将对象分组在一起，而不需要再创建一个扩展自_DisplayObjectContainer_的子类。
可以看出_Sprite_的另一个优点：它是更快捷的类型。
通常，这是我更喜欢它的主要原因。
像大多数程序员一样，我也是一个懒人！
====

因此，要将文本和图像组合在一起，您可以创建一个sprite，并将文本和图像添加为_children_：

[source, as3]
----
var sprite:Sprite = new Sprite(); // <1>
var image:Image = new Image(texture);
var textField:TextField = new TextField(200, 50, "Ay caramba!");
sprite.addChild(image); // <2>
sprite.addChild(textField); // <3>
----
<1> 创建sprite。
<2> 向sprite中添加一个_Image_。
<3> 向sprite中添加一个_TextField_。

添加子项的顺序很重要 - 它们按照放置顺序来决定显示层次。
这里，`textField`将出现在`image`前面。

.一个聊天气泡，由一个图像和一个TextField组成。
image::speech-bubble.png[Speech Bubble, 600]

现在那些对象被分组到同一个sprite里了，你可以把sprite当成一个整体来使用。

[source, as3]
----
var numChildren:int = sprite.numChildren; // <1>
var totalWidth:Number = sprite.width; // <2>
sprite.x += 50; // <3>
sprite.rotation = deg2rad(90); // <4>
----
<1> 查询子对象个数。 这里，结果将是“2”。
<2> `width`和`height`计算了子对象的大小和位置。
<3> 向右移动50点。
<4> 将组旋转90度（Starling始终使用弧度）。

实际上，_DisplayObjectContainer_定义了许多方法来帮助你操纵它的子对象：

[source, as3]
----
function addChild(child:DisplayObject):void;
function addChildAt(child:DisplayObject, index:int):void;
function contains(child:DisplayObject):Boolean;
function getChildAt(index:int):DisplayObject;
function getChildIndex(child:DisplayObject):int;
function removeChild(child:DisplayObject, dispose:Boolean=false):void;
function removeChildAt(index:int, dispose:Boolean=false):void;
function swapChildren(child1:DisplayObject, child2:DisplayObject):void;
function swapChildrenAt(index1:int, index2:int):void;
----

=== Coordinate Systems

Every display object has its own coordinate system.
The `x` and `y` properties, for example, are not given in screen coordinates: they are always depending on the current coordinate system.
That coordinate system, in turn, is depending on your position within the display list hierarchy.

To visualize this, imagine pinning sheets of paper onto a pinboard.
Each sheet represents a coordinate system with a horizontal x-axis and a vertical y-axis.
The position you stick the pin through is the root of the coordinate system.

.Coordinate systems act like the sheets on a pinboard.
image::coordinate-systems.png[Coordinage Systems]

Now, when you rotate the sheet of paper, everything that is drawn onto it (e.g. image and text) will rotate with it -- as do the x- and y-axes.
However, the root of the coordinate system (the pin) stays where it is.

The position of the pin therefore represents the point the x- and y-coordinates of the sheet are pointing at, relative to the parent coordinate system (= the pin-board).

Keep the analogy with the pin-board in mind when you create your display hierarchy.
This is a very important concept you need to understand when working with Starling.

=== Custom Display Objects

I mentioned this already: when you create an application, you split it up into logical parts.
A simple game of chess might contain the board, the pieces, a pause button and a message box.
All those elements will be displayed on the screen -- thus, each will be represented by a class derived from _DisplayObject_.

Take a simple message box as an example.

.A game's message box.
image::msgbox.png[Message Box]

That's actually quite similar to the speech bubble we just created; in addition to the background image and text, it also contains two buttons.

This time, instead of just grouping the object together in a sprite, we want to encapsulate it into a convenient class that hides any implementation details.

To achieve this, we create a new class that inherits from _DisplayObjectContainer_.
In its constructor, we create everything that makes up the message box:

[source, as3]
----
public class MessageBox extends DisplayObjectContainer
{
    [Embed(source = "background.png")]
    private static const BackgroundBmp:Class;

    [Embed(source = "button.png")]
    private static const ButtonBmp:Class;

    private var _background:Image;
    private var _textField:TextField;
    private var _yesButton:Button;
    private var _noButton:Button;

    public function MessageBox(text:String)
    {
        var bgTexture:Texture = Texture.fromEmbeddedAsset(BackgroundBmp);
        var buttonTexture:Texture = Texture.fromEmbeddedAsset(ButtonBmp);

        _background = new Image(bgTexture);
        _textField  = new TextField(100, 20, text);
        _yesButton  = new Button(buttonTexture, "yes");
        _noButton   = new Button(buttonTexture, "no");

        _yesButton.x = 10;
        _yesButton.y = 20;
        _noButton.x  = 60;
        _noButton.y  = 20;

        addChild(_background);
        addChild(_textField);
        addChild(_yesButton);
        addChild(_noButton);
    }
}
----

Now you have a simple class that contains a background image, two buttons and some text.
To use it, just create an instance of _MessageBox_ and add it to the display tree:

[source, as3]
----
var msgBox:MessageBox = new MessageBox("Really exit?");
addChild(msgBox);
----

You can add additional methods to the class (like `fadeIn` and `fadeOut`), and code that is triggered when the user clicks one of those buttons.
This is done using Starling's event mechanism, which is shown in a later chapter.

=== Disposing Display Objects

When you don't want an object to be displayed any longer, you simply remove it from its parent, e.g. by calling `removeFromParent()`.
The object will still be around, of course, and you can add it to another display object, if you want.
Oftentimes, however, the object has outlived its usefulness.
In that case, it's a good practice to dispose it.

[source, as3]
----
msgBox.removeFromParent();
msgBox.dispose();
----

When you dispose display objects, they will free up all the resources that they (or any of their children) have allocated.
That's important, because many _Stage3D_ related data is not reachable by the garbage collector.
When you don't dispose that data, it will stay in memory, which means that the app will sooner or later run out of resources and crash.

To make things easier, `removeFromParent()` optionally accepts a Boolean parameter to dispose the DisplayObject that is being removed.
That way, the code from above can be simplified to this single line:

[source, as3]
----
msgBox.removeFromParent(true);
----

=== Pivot Points

Pivot Points are a feature you won't find in the traditional display list.
In Starling, display objects contain two additional properties: `pivotX` and `pivotY`.
The pivot point of an object (also known as _origin_, _root_ or _anchor_) defines the root of its coordinate system.

Per default, the pivot point is at `(0, 0)`; in an image, that is the top left position.
Most of the time, this is just fine.
Sometimes, however, you want to have it at a different position -- e.g. when you want to rotate an image around its center.

Without a pivot point, you'd have to wrap the object inside a container sprite in order to do that:

[source, as3]
----
var image:Image = new Image(texture);

var sprite:Sprite = new Sprite(); // <1>
image.x = -image.width / 2.0;
image.y = -image.height / 2.0;
sprite.addChild(image); // <2>

sprite.rotation = deg2rad(45); // <3>
----
<1> Create a sprite.
<2> Add an image so that its center is exactly on top of the sprite's origin.
<3> Rotating the sprite will rotate the image around its center.

Most long-time Flash developers will know this trick; it was needed quite regularly.
One might argue, however, that it's a lot of code for such a simple thing.
With the pivot point, the code is reduced to the following:

[source, as3]
----
var image:Image = new Image(texture);
image.pivotX = image.width  / 2.0; // <1>
image.pivotY = image.height / 2.0; // <2>
image.rotation = deg2rad(45); // <3>
----
<1> Move `pivotX` to the horizontal center of the image.
<2> Move `pivotY` to the vertical center of the image.
<3> Rotate around the center.

No more container sprite is needed!
To stick with the analogy used in previous chapters: the pivot point defines the position where you stab the pin through the object when you attach it to its parent.
The code above moves the pivot point to the center of the object.

.Note how moving the pivot point changes how the object rotates.
image::pivot-point.png[Pivot Point]

Now that you have learned how to control the pivot point coordinates individually, let's take a look at the method `alignPivot()`.
It allows us to move the pivot point to the center of the object with just one line of code:

[source, as3]
----
var image:Image = new Image(texture);
image.alignPivot();
image.rotation = deg2rad(45);
----

Handy huh?

Furthermore, if we want the pivot point somewhere else (say, at the bottom right), we can optionally pass alignment arguments to the method:

[source, as3]
----
var image:Image = new Image(texture);
image.alignPivot(Align.RIGHT, Align.BOTTOM);
image.rotation = deg2rad(45);
----

That code rotates the object around the bottom right corner of the image.

==== Gotchas

Be careful: the pivot point is always given in the _local_ coordinate system of the object.
That's unlike the `width` and `height` properties, which are actually relative to the _parent_ coordinate system.
That leads to surprising results when the object is e.g. scaled or rotated.

For example, think of an image that's 100 pixels wide and scaled to 200% (`image.scaleX = 2.0`).
That image will now return a `width` of 200 pixels (twice its original width).
However, to center the pivot point horizontally, you'd still set `pivotX` to `50`, not `100`!
In the _local_ coordinate system, the image is still 100 pixels wide -- it just appears wider in the _parent_ coordinate system.

It might be easier to understand when you look back the code from the beginning of this section, where we centered the image within a parent sprite.
What would happen if you changed the `scale` of the sprite?
Would this mean that you have to update the position of the image to keep it centered?
Of course not.
The scale does not affect what's happening _inside_ the sprite, just how it looks from the _outside_.
And it's just the same with the pivot point property.

TIP: If you still get a headache picturing that (as it happens to me, actually), just remember to set the pivot point _before_ changing the scale or rotation of the object.
That will avoid any problems.
