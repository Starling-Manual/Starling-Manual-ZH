== 什么是Starling?
ifndef::imagesdir[:imagesdir: ../../img]

Starling 框架允许您在ActionScript 3中创建硬件加速应用程序.
主要目标是创建2D游戏，但Starling可用于任何图形应用程序.
借助于Adobe AIR，基于Starling的应用程序可以部署到所有主要的移动和桌面平台.

.这个红色的小鸟代表着Starling框架.
image::starling-bird.png["The Starling logo.", 400]

虽然Starling模拟了Adobe AIR / Flash的经典显示列表架构，但它提供了更好的性能：所有对象都由GPU直接渲染（使用Stage3D API）.
Starling完成了一整套架构设计，能更好的与GPU协同工作，集成了对常用的游戏开发任务的核心支持.
Starling对开发人员隐藏了Stage3D内部接口，但是对于需要完全性能和灵活性的用户来说，它也很容易访问.

=== 为什么要另一个显示API?

如上所述，Starling的API与本机Flash API非常相似，即：flash.display软件包.
所以你可能会问：为什么要花费巨大的努力来重建Flash内部结构...，这样做真的好吗?

原因是:原生的flash.display API，它灵活的显示列表，矢量能力，文本呈现，滤镜等等，都是针对台式计算机时代设计的.
这些台式计算机拥有强大的CPU和非常原始的图形硬件（相对现代标准）.
但是，今天的移动硬件具有几乎颠倒的设置：拥有非常先进的图形芯片和相对较弱的CPU（即节省电池的）.

那么问题来了：如何让原有针对纯CPU渲染设计的API能够快速有效地利用GPU，显然，这是是非常困难的（即使有可能的话）.
footnote:[以下是Adobe某工程师的一篇有趣的文章: http://tinyurl.com/hkbdgfn]
这种尝试失败了，因此，Flash插件也一直未能在手机和平板电脑上的浏览器中出现.

值得称道的是，Adobe非常清楚这个问题.
这就是为什么，在2011年，他们推出了一个称为Stage3D的低级图形API.
这个API确实是够低级的; 它基本上是一个OpenGL和DirectX的简单包装，允许开发人员访问GPU的原始功能而已.

那么问题又来了：这样一个低级的API并没能帮助用户利用上已有的经典显示列表，至少不能方便的使用.
正因为Stage3D API是如此低级，所以它不是一个典型的开发者可以（或应该）用来直接创建应用程序或游戏的API.
footnote:[我猜是用汇编语言编写一些像素着色器]
显然，Adobe需要一个建立在Stage3D之上，但是像'flash.display'一样容易使用的更高级的API.

嗯...是时候了，Starling进入舞台了（一语双关）!
它是基于Stage3D同时尽可能模仿经典的Flash API而设计的.
这使得它既有可能充分利用现代强大的图形硬件，又可以使用无数的开发人员已经熟悉的概念.

Adobe当然可以自己制作这样的API.
然而，由大公司构建的API具有变得膨胀和不灵活的毛病.
一个小型的开源项目，加上一个公平开放、交流活跃的开发者的社区，可以更迅速地达成目的.
Flash和AIR平台产品经理Thibault Imbert洞悉了这一切， 2011年，Starling项目在他的带领下由此开启.

直到今天，它仍由Adobe资助和支持.

=== Starling的核心观念

Starling的核心目标之一是使其尽可能轻量和易于使用.
在我看来，开源库不应该只是易于使用 - 它也应该鼓励开发人员深入阅读代码.
我希望开发人员能够了解幕后的情况; 只有这样，他们才能够扩展和修改它，直到它完全满足需求.

所以Starling的源文件都有据可查，简明扼要.
由于只有大约15000行代码，它可能比大多数游戏源码更小!

[TIP]
====
我真的想强调：如果你有一天卡住或困惑为什么你的代码不能正常工作，不要犹豫，阅读Starling的源代码.
通常，你会很快看到发生了什么问题，你会更好地理解它的内部实现机制.
====

Starling的另一个重要目标当然是它尽量亲近本机显示列表架构.
这不仅是因为我真的很喜欢显示列表背后的整个思路，还使开发人员能够轻松地过渡到Starling.

然而，我从来没有试图创建一个完美的复制品.
针对GPU编程需要具体的概念，那些概念应该被突出!
例如，纹理和网格的概念旨在与原始API无缝融合，就像它一直是为GPU设计的.
