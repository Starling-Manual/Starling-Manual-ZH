== 性能优化

虽然Starling模仿Flash的经典显示列表，但幕后的功能是完全不同的。
要实现最佳性能，您必须了解其架构的一些关键概念。
以下列表是您可以遵循的最佳做法，让您的游戏尽可能快地运行。

=== 普通AS3程序通用提示

==== 总是构建发行版本

首先也是最重要的一条：在测试性能时始终构建发行(release)版本。
与传统的Flash项目不同，当您使用Stage3D框架时，发行版本会产生巨大的差异。
根据您正在开发的平台不同，运行时速度差异可能非常大;发行版帧率甚至可以轻松达到调试版帧率的倍数。

* 在Flash Builder中，通过单击菜单：工程 [导出发行版本] 构建发布版本。
* 在Flash Develop中，选择“发布”配置并构建项目;
  然后在执行“PackageApp.bat”脚本时选择“ipa-ad-hoc”或“ipa-app-store”选项。
* 在IntelliJ IDEA中，选择菜单：构建 [AIR应用程序包] ;为Android选择“发布”，iOS选择“临时发行”。
  对于非AIR项目，请取消选择模块编译器选项中的“生成可调试SWF”。
* 如果您从命令行构建Starling项目，请确保`-optimize`为true，`-debug`为false。

.不要因此Flash Builder对话框而感到困惑。
image::not-release-build.png[Flash Builder Dialog]

==== 检查你的硬件

确保Starling确实使用GPU进行渲染。
这很容易检查：如果“Starling.current.context.driverInfo”包含字符串“software”，则Stage3D处于软件回退模式，否则使用GPU。

此外，一些移动设备可以在省电模式中运行。
进行性能测试时，请务必将其关闭。

==== 设置帧速率

无论您怎么优化,您的应用程序仍然以每秒24帧运行？
那么你可能从来没有设置你想要的帧速率，你看到只是Flash Player的默认设置。

要改变这一点，可以在启动类中使用相应的元数据标签，或者在Flash运行阶段手动设置帧速率。

[source, as3]
----
[SWF(frameRate="60", backgroundColor="#000000")]
public class Startup extends Sprite
{ /* ... */ }

// 或其他任何地方
Starling.current.nativeStage.frameRate = 60;
----

==== 使用Adobe Scout

Adobe Scout不仅对“memory_management_scout，内存分析”有用;它在性能分析方面同样强大。

它允许您实际查看每个ActionScript（和Starling）方法中花费了多少时间。
这是非常有用的，因为它显示了您可以从任何优化中获得最大收益的位置。
没有它，你最终优化的代码可能会在实际上与帧速率无关的区域！

TIP: 记住，过早优化是所有不幸的根源！

与传统的分析器相比，它的优点在于，它还可以在发布模式下运行，所有优化都已做到位。
这确保其输出非常准确。

==== 异步解码加载的图像

默认情况下，如果您使用Loader加载PNG或JPEG图像，则图像数据不会立即解码，而是首次使用时。
这种情况发生在主线程上，可能会导致应用程序在纹理创建时表现卡顿。
为了避免这种情况，请将图像解码策略标志设置为“ON_LOAD”。
这将导致图像在Loader的后台线程中直接解码。

[source, as3]
----
loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;
loader.load(url, loaderContext);
----

另一方面，您可能正在使用Starling的AssetManager加载纹理，不是吗？
在这种情况下，不要担心，它内部已经采用这种做法。

==== 避免 "for each"

当使用经常重复或深入嵌套的循环时，最好避免“for each”而改用经典的“for i”优化性能： http://jacksondunstan.com/articles/358[better] 。
此外，请注意，每次循环都会执行循环条件一次，因此将其保存到一个额外的变量中速度更快。

[source, as3]
----
// 慢:
for each (var item:Object in array) { ... }

// 更快:
for (var i:int=0; i<array.length; ++i) { ... }

// 最快:
var length:int = array.length;
for (var i:int=0; i<length; ++i) { ... }
----

==== 避免分配内存

避免创建大量临时对象。
它们占用内存，需要被垃圾收集器清理，这可能会在运行时产生小的卡顿。

[source, as3]
----
// 较差:
for (var i:int=0; i<10; ++i)
{
    var point:Point = new Point(i, 2*i);
    doSomethingWith(point);
}

// 更好:
var point:Point = new Point();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
----

实际上，Starling包含一个帮助类：Pool。
它提供了对象池,能存取经常需要的对象，如Point，Rectangle和Matrix。
您可以从该池中“借”对象，并在完成后返还到池中。

[source, as3]
----
// best:
var point:Point = Pool.getPoint();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
Pool.putPoint(point); // 不要忘记这个！
----

=== Starling特性提示

==== 最大限度地减少状态变化

你已经知道，Starling使用Stage3D渲染显示列表。
这意味着所有绘图都是由GPU完成的。

现在，Starling可以一个接一个地将四边形发送到GPU，逐一绘制。
事实上，最初的Starling发行版就是这样工作的！
但是，为了获得最佳性能，GPU更适合获得一大堆数据，同时绘制所有数据。

这就是为什么更新的Starling版本在将它们发送到GPU之前,将尽可能多的四边形拼凑在一起的原因。
不过，它只能批量渲染具有相似属性的四边形。
每当遇到具有不同“状态”的四边形时，GPU将发生“状态改变”，并绘制当前批次的四边形。

[NOTE]
====
我在本节中使用四边形(Quad)和图像(Image)同义。
记住，Image只是Quad的一个子类，只是它添加了几个方法。
此外，Quad扩展网格(Mesh)，并且以下内容也适用于Mesh。
====

这些是构成状态的关键属性：

* 纹理 (不同的纹理来自同一图集)
* 显示对象的blendMode(混合模式)
* Mesh/Quad/Image的textureSmoothing(平滑)值
* Mesh/Quad/Image的textureRepeat(重复填充)值

如果您以尽可能少的更改状态的制作方式设置场景，则您的渲染性能将获得巨大的提升。

Again, Starling's statics display provides useful data.
It shows exactly how many draw calls are executed per frame.
The more state changes you have, the higher this number will be.

.The statistics display includes the current number of draw calls.
image::stats-display.png[Statistics Display]

[NOTE]
====
The statistics display causes draw calls, as well.
However, Starling explicitly decrements the draw count displayed to take that into account.
====

Your target should always be to keep it as low as possible.
The following tips will show you how.

===== The Painter's Algorithm

To know how to minimize state changes, you need to know the order in which Starling processes your objects.

Like Flash, Starling uses the _Painter's algorithm_ to process the display list.
This means that it draws your scene like a painter would do it: starting at the object at the bottom layer (e.g. the background image) and moving upwards, drawing new objects on top of previous ones.

.Drawing a scene with the Painter's algorithm.
image::painters-algorithm.png[Painter's algorithm]

If you'd set up such a scene in Starling, you could create three sprites: one containing the mountain range in the distance, one with the ground, and one with the vegetation.
The mountain range would be at the bottom (index 0), the vegetation at the top (index 2).
Each sprite would contain images that contain the actual objects.

.The scene graph of the landscape from above.
image::landscape.png[Landscape Scene Graph]

On rendering, Starling would start at the left with "Mountain 1" and continue towards the right, until it reaches "Tree 2".
If all those objects have a different state, this would mean six draw calls.
That's exactly what will happen if you load each object's texture from a separate Bitmap.

// <note tip>
// Another tool at your disposal is the [[http://doc.starling-framework.org/core/starling/display/DisplayObjectContainer.html#sortChildren()|DisplayObjectContainer::sortChildren()]] method which can be used to sort layers, within a ''Sprite'' object for example, based on properties such as ''x'', ''y'', ''alpha'' etc. The method accepts a compare function which means you can sort objects based on any criteria you wish! :-D
// </note>

===== The Texture Atlas

That's one of the reasons why texture atlases are so important.
If you load all those textures from one single atlas, Starling will be able to draw all objects at once!
(At least if the other properties listed above do not change.)

.The same scene graph, now using a single atlas texture.
image::landscape-2.png[Landscape Scene Graph 2]

The consequence of this is that you should _always_ use an atlas for your textures.
Here, each image uses the same atlas (depicted by all nodes having the same color).

Sometimes, though, not all of your textures will fit into a single atlas.
The size of textures is limited, so you'll run out of space sooner or later.
But this is no problem, as long as you arrange your textures in a smart way.

.The order of objects makes a difference.
image::landscape-3.png[Landscape Scene Graph 3]

Both those examples use two atlases (again, one color per atlas).
But while the display list on the left will force a state change for each object, the version on the right will be able to draw all objects in just two batches.

==== Use the MeshBatch class

The fastest way to draw a huge number of quads or other meshes at once is to use the _MeshBatch_ class.
That's the same class that is used internally by Starling for all rendering, so it's heavily optimized.footnote:[If you're still using Starling 1.x, look for ''QuadBatch'' instead.]
It works like this:

[source, as3]
----
var meshBatch:MeshBatch = new MeshBatch();
var image:Image = new Image(texture);

for (var i:int=0; i<100; ++i)
{
    meshBatch.addMesh(image);
    image.x += 10;
}

addChild(meshBatch);
----

Did you notice? You can add the same image as often as you want!
Furthermore, adding it is a very fast operation; e.g. no event will be dispatched (which is the case when you add an object to a container).

As expected, this has some downsides, though:

* All the objects you add must have the same state (i.e. use textures from the same atlas).
  The first image you add to the MeshBatch will decide on its state.
  You can't change the state later, except by resetting it completely.
* You can only add instances of the _Mesh_ class or its subclasses (that includes _Quad_, _Image_, and even _MeshBatch_).
* Object removal is quite tricky: you can only remove meshes by trimming the number of vertices and indices of the batch.
  However, you can overwrite meshes at a certain index.

For these reasons, it's only suitable for very specific use-cases (the _BitmapFont_ class, for example, uses a mesh batch internally).
In those cases, it's definitely the fastest option, though. You won't find a more efficient way to render a huge number of objects in Starling.

==== Batch your TextFields

Per default, a TextField will require one draw call, even if your glyph texture is part of your main texture atlas.
That's because long texts require a lot of CPU time to batch; it's faster to simply draw them right away (without copying them to a _MeshBatch_).

However, if your text field contains only a few letters (rule of thumb: below 16), you can enable the `batchable` property on the TextField.
With that enabled, your texts will be batched just like other display objects.

==== Use BlendMode.NONE

If you've got totally opaque, rectangular textures, help the GPU by disabling blending for those textures.
This is especially useful for large background images.

[source, as3]
----
backgroundImage.blendMode = BlendMode.NONE;
----

Naturally, this will also mean an additional state change, so don't overuse this technique.
For small images, it's probably not worth the effort (except if they'd cause a state change, anyway, for some other reason).

==== Use stage.color

Oftentimes, the actual stage color is actually never seen in your game, because there are always images or meshes on top of the stage.

In that case, always set it to clear black (`0x0`) or white (`0xffffff`).
There seems to be a fast hardware optimization path for a `context.clear` on some mobile hardware when it is called with either all 1's or all 0's.
Some developers reported a full millisecond of spared rendering time per frame, which is a very nice gain for such a simple change!

[source, as3]
----
[SWF(backgroundColor="#0")]
public class Startup extends Sprite
{
    // ...
}
----

On the other hand, if the background of your game is a flat color, you can make use of that, too: just set the stage color to that value instead of displaying an image or a colored quad.
Starling has to clear the stage once per frame, anyway -- thus, if you change the stage color, that operation won't cost anything.

[source, as3]
----
[SWF(backgroundColor="#ff2255")]
public class Startup extends Sprite
{
    // ...
}
----

==== Avoid querying width and height

The `width` and `height` properties are more expensive than one would guess intuitively, especially on sprites.
A matrix has to be calculated, and each vertex of each child will be multiplied with that matrix.

For that reason, avoid accessing them repeatedly, e.g. in a loop.
In some cases, it might even make sense to use a constant value instead.

[source, as3]
----
// bad:
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wall.width)
        child.removeFromParent();
}

// better:
var wallWidth:Number = wall.width;
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wallWidth)
        child.removeFromParent();
}
----

==== Make containers non-touchable

When you move the mouse/finger over the screen, Starling has to find out which object is hit.
This can be an expensive operation, because it requires a hit-test on each and every display object (in the worst case).

Thus, it helps to make objects _untouchable_ if you don't care about them being touched, anyway.
It's best to disable touches on complete containers: that way, Starling won't even have to iterate over their children.

[source, as3]
----
// good:
for (var i:int=0; i<container.numChildren; ++i)
    container.getChildAt(i).touchable = false;

// even better:
container.touchable = false;
----

==== Hide objects that are outside the Stage bounds

Starling will send any object that is part of the display list to the GPU.
This is true even for objects that are outside the stage bounds!

You might wonder: why doesn't Starling simply ignore those invisible objects?
The reason is that checking the visibility in a universal way is quite expensive.
So expensive, in fact, that it's faster to send objects up to the GPU and let it do to the clipping.
The GPU is actually very efficient with that and will abort the whole rendering pipeline very early if the object is outside the screen bounds.

However, it still takes time to upload that data, and you can avoid that.
Within the high level game logic, it's often easier to make visibility checks (you can e.g. just check the x/y coordinates against a constant).
If you've got lots of objects that are outside those bounds, it's worth the effort.
Remove those elements from the stage or set their `visible` property to `false`.

==== Make use of Event Pooling

Compared to classic Flash, Starling adds an additional method for event dispatching:

[source, as3]
----
// classic way:
object.dispatchEvent(new Event("type", bubbles));

// new way:
object.dispatchEventWith("type", bubbles);
----

The new approach will dispatch an event object just like the first one, but behind the scenes, it will pool event objects for you.
That means that you will save the garbage collector some work.

In other words, it's less code to write _and_ is faster -- thus, it's the preferred way to dispatch events.
(Except if you need to dispatch a custom subclass of `Event`; they cannot be dispatched with that method.)
