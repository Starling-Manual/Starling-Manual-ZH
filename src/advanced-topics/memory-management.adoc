== 内存管理

许多Starling开发人员使用该框架为移动设备创建应用和游戏。
几乎所有这些开发人员迟早都会发现（以自己惨痛的经验）移动设备在内存上的总是感觉不够用。
这是为什么？

* 大多数移动设备具有极高分辨率的屏幕。
* 这样的设备的2D游戏需要同样高分辨率的纹理。
* 可用RAM太小，无法容纳所有纹理数据。

换句话说，一个真正的恶性组合。

如果内存不足时程序仍在运行，会发生什么？
大多数时候，你会得到着名的错误3691（超出此资源类型的资源限制），您的应用程序将崩溃。
以下提示将告诉您如何避免这种讨厌的错误！

=== 清除垃圾

当你不再需要一个对象时，别忘了在它上面调用`dispose`。
与传统的Flash对象不同，垃圾收集器不会清理任何Stage3D资源！
你自己负责管理这个内存。

==== 纹理

纹理--这就是那些是你需要照顾的最重要的对象。
纹理总是占据你内存中最大的份额。

当然，Starling试图帮助你。
例如，当您从图集加载纹理时，您只需要处理图集，而不是实际的SubTextures。
只有图集才需要GPU内存，“子”纹理只会引用图集的纹理,不会实际占据GPU内存。

[source, as3]
----
var atlas:TextureAtlas = ...;
var hero:Texture = atlas.getTexture("hero");

atlas.dispose(); // 将失效的“英雄”。
----

==== 显示对象

虽然显示对象本身不需要很多显存（有些根本不需要），但失效时调用dispose也是一个很好的做法。
特别注意“重”对象，如TextFields。

显示对象容器将照顾所有的孩子，正如预期的那样。
当你处理一个容器时，所有的孩子将被自动处理。

[source, as3]
----
var parent:Sprite = new Sprite();
var child1:Quad = new Quad(100, 100, Color.RED);
var child2:Quad = new Quad(100, 100, Color.GREEN);

parent.addChild(child1);
parent.addChild(child2);

parent.dispose(); // 子对象的dispose方法也将被自动调用
----

总而言之，最新的Starling版本在处理显示对象时变得更加宽容了。
大多数显示对象不再存储Stage3D资源，因此如果您忘记释放它们，也不会酿成灾难性的后果。

==== Images

这是第一个陷阱：释放图像将不会释放其纹理。

[source, as3]
----
var texture:Texture = Texture.fromBitmap(/* ... */);
var image:Image = new Image(texture);

image.dispose(); // 不会释放纹理，即不会调用image.texture.dispose();
----

那是因为Starling不知道你是否在其他地方使用这种纹理！
毕竟，您其它的图像也可能使用了这种纹理。

另一方面，如果你知道纹理没有在别的地方使用，那就释放它。

[source, as3]
----
image.texture.dispose();
image.dispose();
----

==== 滤镜

滤镜也有点玄机。
当您释放对象时，其滤镜也将被释放：

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.dispose(); // 此方法会将滤镜一并释放掉。
----

但请注意：以下类似的代码不会释放滤镜：

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.filter = null; // 调用此方法并没有真正的释放掉滤镜
----

同样的原因，Starling不知道你是否想在其他地方使用这个滤镜对象。

但实际上这并不是一个问题。
滤镜没有释放，但Starling仍将清理所有资源。
所以这不会造成内存泄漏。

NOTE: 在之前的Starling版本（<2.0）中，上述做法会造成内存泄漏。

=== 不要嵌入纹理

ActionScript开发人员常常使用“Embed”元数据将其位图直接嵌入到SWF文件中。
这对网页来说非常棒，因为它允许您将所有游戏的数据合并到一个文件中。

我们已经在“设备丢失”部分看到，这种方法在Starling（或一般的Stage3D）中有一些严重的缺点。
归结为：纹理将占用两份内存：一份在常规内存中，一份在显示内存中。

[source, as3]
----
[Embed(source="assets/textures/hero.png")]
private static var Hero:Class; // <1>

var texture:Texture = Texture.fromEmbeddedAsset(Hero); // <2>
----
<1> 该类存储在常规内存中。
<2> 纹理存储在图形存储器中。

请注意，此示例使用“Texture.fromEmbeddedAsset”加载纹理。
由于“设备丢失”中讨论的原因，替代方案（“Texture.fromBitmap”）会使用更多的内存。

保证纹理真的只存储在图形内存中的唯一方法是通过URL加载纹理。
如果你使用AssetManager来执行这个任务，那么需要做的工作不是很多。

[source, as3]
----
var appDir:File = File.applicationDirectory;
var assets:AssetManager = new AssetManager();

assets.enqueue(appDir.resolvePath("assets/textures"));
assets.loadQueue(...);

var texture:Texture = assets.getTexture("hero");
----

=== 使用矩形纹理

Starling的Texture类实际上只是两个Stage3D相关类的包装器：

`flash.display3D.textures.Texture` ::可用于所有配置文件。 支持mipmaps和包装，但要求纹理边长是2的幂。
`flash.display3D.textures.RectangleTexture` ::可用于`BASELINE`开头的低配置文件。 没有mipmaps，没有包装，但支持任意边长。

前者（“纹理”）有一个奇怪的，鲜为人知的副作用：它将始终为mipmap分配内存，无论您是否需要它们。
这意味着你会浪费大约三分之一的纹理内存！

因此，最好使用替代（“RectangleTexture”）。
Starling将尽可能使用这种纹理类型。

但是，如果运行在仅仅包含“BASELINE”的配置文件环境中，并且如果您禁用mipmaps，那么它只能执行此操作。
可以通过选择最佳的Context3D配置文件来满足第一个要求。
如果您使用Starling的默认构造函数，则会自动完成这一切。

[source, as3]
----
// init Starling like this:
... = new Starling(Game, stage);

// that's equivalent to this:
... = new Starling(Game, stage, null, null, "auto", "auto");
----

最后一个参数（`auto`）会告诉Starling使用最好的配置文件。
这意味着如果设备支持RectangleTextures，Starling将会使用它们。

至于mipmap：只有在明确要求的时候才会创建它们。
一些“Texture.from ...”工厂方法包含这样一个参数，而AssetManager具有一个`useMipMaps`属性。
默认情况下，它们始终处于禁用状态。

=== 使用ATF纹理

我们之前已经讨论过“ATF贴图”，但是在本节再次提及它们是更有意义的。
记住，GPU无法直接使用JPG或PNG压缩;这些文件始终在CPU阶段完成解压，并以未压缩形式上传到显卡。

但ATF纹理不是这样：它们可以直接以压缩形式上传给显卡并直接渲染，这样可以节省大量内存。
所以如果你跳过了ATF部分，我建议你回头再仔细看一下！

当然，ATF纹理的缺点是会降低图像质量。
但您可以尝试以下技巧，即使这并非适合所有类型的游戏：

. 创建您的纹理比实际需要的更大一点。
. 现在用ATF工具压缩它们。
. 在运行时，将它们缩小到原来的大小。

您仍将节省相当多的内存，并且压缩痕迹将变得不那么明显。

=== Use 16 bit Textures

If ATF textures don't work for you, chances are that your application uses a comic-style with a limited color palette.
I've got good news for you: for these kinds of textures, there's a different solution!

* The default texture format (`Context3DTextureFormat.BGRA`) uses 32 bits per pixel (8 bits for each channel).
* There is an alternative format (`Context3DTextureFormat.BGRA_PACKED`) that uses only half of that: 16 bits per pixel (4 bits for each channel).

You can use this format in Starling via the `format` argument of the `Texture.from...` methods, or via the AssetManager's `textureFormat` property.
This will save you 50% of memory!

Naturally, this comes at the price of a reduced image quality.
Especially if you're making use of gradients, 16 bit textures might become rather ugly.
However, there's a solution for this: dithering!

.Dithering can conceal a reduced color depth.
image::dithering.png[Dithering]

To make it more apparent, the gradient in this sample was reduced to just 16 colors (4 bits).
Even with this low number of colors, dithering manages to deliver an acceptable image quality.

Most image processing programs will use dithering automatically when you reduce the color depth.
_TexturePacker_ has you covered, as well.

The _AssetManager_ can be configured to select a suitable color depth on a per-file basis.

[source, as3]
----
var assets:AssetManager = new AssetManager();

// enqueue 16 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.enqueue(/* ... */);

// enqueue 32 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA;
assets.enqueue(/* ... */);

// now start the loading process
assets.loadQueue(/* ... */);
----

=== Avoid Mipmaps

Mipmaps are downsampled versions of your textures, intended to increase rendering speed and reduce aliasing effects.

.Sample of a texture with mipmaps.
image::mipmap.jpg[Mipmap]

Since version 2.0, Starling doesn't create any mipmaps by default.
That turned out to be the preferable default, because without mipmaps:

* Textures load faster.
* Textures require less texture memory (just the original pixels, no mipmaps).
* Blurry images are avoided (mipmaps sometimes become fuzzy).

On the other hand, activating them will yield a slightly faster rendering speed when the object is scaled down significantly, and you avoid aliasing effects (i.e. the effect contrary to blurring).
To enable mipmaps, use the corresponding parameter in the `Texture.from...` methods.

=== Use Bitmap Fonts

As already discussed, TextFields support two different kinds of fonts: TrueType fonts and Bitmap Fonts.

While TrueType fonts are very easy to use, they have a few downsides.

* Whenever you change the text, a new texture has to be created and uploaded to graphics memory. This is slow.
* If you've got many TextFields or big ones, this will require a lot of texture memory.

Bitmap Fonts, on the other hand, are

* updated very quickly and
* require only a _constant_ amount of memory (just the glyph texture).

That makes them the preferred way of displaying text in Starling.
My recommendation is to use them whenever possible!

TIP: Bitmap Font textures are a great candidate for 16 bit textures, because they are often just pure white that's tinted to the actual TextField color at runtime.

=== Optimize your Texture Atlas

It should be your top priority to pack your texture atlases as tightly as possible. Tools like https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] have several options that will help with that:

* Trim transparent borders away.
* Rotate textures by 90 degrees if it leads to more effective packing.
* Reduce the color depth (see above).
* Remove duplicate textures.
* etc.

Make use of this!
Packing more textures into one atlas not only reduces your overall memory consumption, but also the number of draw calls (more on that in the next chapter).

[[memory_management_scout]]
=== Use Adobe Scout

https://www.adobe.com/products/scout.html[Adobe Scout] is a lightweight but comprehensive profiling tool for ActionScript and Stage3D.
Any Flash or AIR application, regardless of whether it runs on mobile devices or in browsers, can be quickly profiled with no change to the code -- and Adobe Scout quickly and efficiently detects problems that could affect performance.

With Scout, you can not only find performance bottlenecks in your ActionScript code, but you'll also find a detailed roundup of your memory consumption over time, both for conventional and graphics memory.
This is priceless!

NOTE: Adobe Scout is part of the _free_ version of Adobe's Creative Cloud membership. You don't have to become a paying subscriber of CC to get it.

Here is a great tutorial from Thibault Imbert that explains in detail how to work with Adobe Scout: http://www.adobe.com/devnet/scout/articles/adobe-scout-getting-started.html[Getting started with Adobe Scout]

.Adobe Scout
image::scout-screenshot.png[Adobe Scout]

=== Keep an Eye on the Statistics Display

The statistics display (available via `starling.showStats`) includes information about both conventional memory and graphics memory.
It pays off to keep an eye on these values during development.

Granted, the conventional memory value is often misleading -- you never know when the garbage collector will run.
The graphics memory value, on the other hand, is extremely accurate.
When you create a texture, the value will rise; when you dispose a texture, it will decrease -- immediately.

Actually, when I added this feature to Starling, it took about five minutes and I had already found the first memory leak -- in Starling's demo app.
I used the following approach:

* In the main menu, I noted down the used GPU memory.
* Then I entered the demos scenes, one after another.
* Each time I returned to the main menu, I checked if the GPU memory had returned to the original value.
* After returning from one of the scenes, that value was not restored, and indeed: a code review showed that I had forgotten to dispose one of the textures.

.The statistics display shows the current memory usage.
image::stats-display.png[The statistics display]

Needless to say: Scout offers far more details on memory usage.
But the simple fact that the statistics display is always available makes it possible to find things that would otherwise be easily overlooked.
